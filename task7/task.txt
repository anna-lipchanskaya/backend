CROSS SITE SCRIPTING
в моем коде я изпользовала функцию htmlspecialchars, которая гарантирует, что специальные символы HTML будут отображаться в коде как текст, а не интерпритироваться как часть кода
    echo "Data: " . htmlspecialchars($row['data'], ENT_QUOTES, 'UTF-8') . "<br>";
также я использовала функции (is_numeric($userid)) и обработка полей  elseif (!preg_match('/^\d{4}-\d{2}-\d{2}$/', $data) чтобы мы получали то, что предусмотрено 



 SQL-INJECTION
Я использовала подготовленные запросы с параметрами для работы с базой данных.Поскольку данные отделяются от SQL-кода, вредоносный код, внедренный в данные, не будет интерпретироваться как часть запроса
function db_command($query) {
  global $db;
  $stmt = $db->prepare($query);
  $args = func_get_args();
  array_shift($args);
  $res = $stmt->execute($args);
  return $res;
}



Information Disclosure
Данные для подключения к моей базе MySQL находятся в файле db.php, в котором находятся логин, пароль и название базы данных. Этот файл скрывается и путь к нему прописывается в .gitignore. Таким образом мои данные не высвечиваются в репозитории 
include('../db.php');
global $db;
$db = new PDO('mysql:host=localhost;dbname=' . $db_name, $db_login, $db_pass,
  [PDO::ATTR_PERSISTENT => true, PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]); // Заменить test на имя БД, совпадает с логином uXXXXX



CROSS SITE REQUEST FORGERY
Я использовала CSRF-токен, при входе на сайт генерируется уникальный токен, этот токен сохраняется в сессии пользователя. Вот так токен организован у меня в коде:
// Генерируем CSRF-токен, если его еще нет в сессии
if (!isset($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}

// Получаем токен из сессии
$token = $_SESSION['csrf_token'];
//вставляем токен в форму как невидимое поле
<input type="hidden" name="csrf_token" value="<?php echo $token; ?>">

//получаем токен из POST-запроса
 $submitted_token = filter_input(INPUT_POST, 'csrf_token', FILTER_SANITIZE_STRING);

// Сравниваем с токеном из сессии
if (!$submitted_token || $submitted_token !== $_SESSION['csrf_token']) {
  echo "Неверный токен";
  exit();
  }

INCLUDE-УЯЗВИМОСТИ
Я организовала проверку файлов до их подключения, таким образом можно подклюсить только нужные нам файлы, чтобы пользователь не смог внедрить имя файла, содержащее вредоносный код

 $files = [
 'form.php',
'db.php',
];
function safe_include($file) {
global $files;
 if (in_array($file, $files)) {
  include($file);
 } else {
 echo "Файл неразрешен";
 }
}

function safe_require_once($file) {
global $files;
 if (in_array($file, $files)) {
  require_once($file);
 } else {
 echo "Файл неразрешен";
 }
}
 safe_require_once('db.php');


UPLOAD-УЯЗВИМОСТИ
Мой сайт не предусмотрен для выгрузки файлов на сервер, но я могу составить список идей для устранения этой уязвимости:
1. Проверка типа файла:
   - Не использовать Content-Type, так как его можно подделать. Вместо этого, можно проверить тип файла с помощью функции getimagesize() или других подходящих методов
   - Нужно убедиться, что загруженный файл действительно является изображением

2. Изменение имени файла:
   - Генерировать уникальное имя файла для сохранения на сервере, чтобы избежать возможности перезаписи существующих файлов

3. Ограничение длины имени файла:
   - Установить ограничение на длину имени файла, чтобы предотвратить атаки с длинными именами.

4. Ограничение разрешенных символов в имени файла:
   - Ограничить разрешенные символы в имени файла

5. Ограничение размера файла:
   - Установить максимальный размер загружаемого файла. Это поможет предотвратить переполнение дискового пространства и атаки с большими файлами

6. Хранение загруженных файлов в отдельной директории:
   - Сохранять загруженные файлы в отдельной директории, которая не имеет исполняемых прав.
   - Не хранить загруженные файлы в публичных директориях, чтобы избежать возможности выполнения кода из загруженных файлов.

7. Санитизация имени файла:
   - Перед сохранением файла на сервере, убедиться, что имя файла не содержит опасных символов, таких как ../ или ;

8. Аутентификация и авторизация:
   - Проверить, что пользователь имеет права на загрузку файлов (авторизация)
   - Проверить, что пользователь аутентифицирован перед загрузкой файла

9. Белый список разрешенных расширений файлов:
    - Разрешить только определенные расширения файлов (например, .jpg, .png, .pdf), чтобы избежать загрузки исполняемых файлов

10. Запрет выполнения загруженных файлов:
    - Не давать загруженным файлам права на выполнение на сервере

